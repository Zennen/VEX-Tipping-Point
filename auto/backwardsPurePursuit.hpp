/*
 * @author D Michael Jones, 914M - acetousk
 *
 * The ideas portrayed in this code are mainly from the following
 * documents:
 *      Pure Pursuit            : https://github.com/team914/autolib-pdfs/blob/master/pure-pursuit.pdf
 *      Adaptive Pure Pursuit   : https://github.com/team914/autolib-pdfs/blob/master/adaptive-pure-pursuit.pdf
 *      Path Tracking           : https://github.com/team914/autolib-pdfs/blob/master/path-tracking.pdf
 *      PiLons Position Tracking: https://github.com/team914/autolib-pdfs/blob/master/pilons-position-tracking.pdf
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
#pragma once

#include "util/messages.hpp"
#include "auto/pathGenerator.hpp"
#include "okapi/api/units/QLength.hpp"
#include "okapi/api/units/RQuantity.hpp"
#include "okapi/api/odometry/odomState.hpp"
#include "okapi/api/chassis/controller/odomChassisController.hpp"
#include <cmath>
#include <memory>
#include <utility>
#include <vector>

#define DEBUG

namespace autolib{

class BackwardsPurePursuit {
    public:
    /**
     * PurePursuit Class's Constructor
     *
     * This is the constructor for PurePursuit. The first param is an InternalPath which should be generated by
     * PathGenerator's getPath() method. The second param is the lookaheadDistance of the Pure Pursuit algorithm.
     *
     * @param  {std::vector<IndexedDistancePosePath>} ipaths :
     * @param  {okapi::QLength} ilookaheadDistance           :
     */
    BackwardsPurePursuit( const std::vector<IndexedDistancePosePath> &ipaths, const okapi::QLength &ilookaheadDistance, double ispeed, bool iSlowDown );

    /**
     * This should be run in a loop during your autonomous. The input is the x, y, and theta in global coordinates
     * of where your robot is currently located. This can be calculated using okapi's odometry feature. To access
     * that feature go the the feature/odometry branch on github until the official release of it. It will return
     * what the requested X, Y, Yaw, radius, and length to get to the Goal Point.
     *
     * @param  {okapi::OdomState} or {Pose} ipose :
     * @param  {std::string} iid        :
     * @return {PurePursuitTriangle}    :
     */
    //bool run( double x, double y, double yaw, const std::string &iid, const std::shared_ptr<okapi::OdomChassisController> &controller  );
    bool run( double x, double y, double yaw, const std::string &iid, const std::shared_ptr<okapi::OdomChassisController> &controller  );
    /**
     * This should be used in a loop during your autonomous. It is static, but is meant for the PurePursuit class.
     * It is recommended to use motion profiling for the first parameter. The second parameter should be from your
     * run method from the PurePursuit class. The third method should be from you okapi's ChassisControllerBuilder.
     *
     * Note: Using this method is optional. You can and probably should create your own controller to use the triangle
     * motor output This is only meant for users of okapi >= v4.0.0.
     *
     * @param  {double} reqVelocity                                :
     * @param  {PurePursuitTriangle} triangle                      :
     * @param  {std::shared_ptr<OdomChassisController>} controller :
     */
    protected:
    const std::vector<IndexedDistancePosePath> paths;
    IndexedDistancePosePath path;
    double avgDistanceBetweenPoses;
    double speed;
    bool slowDown;

    IndexedDistancePosePath nearestPoses;
    PosePath currentPoses;
    IndexedPosePath goalPoses;
    std::vector<PurePursuitTriangle> triangles;

    double lookaheadDistance;

    void findPath( const std::string & );
    int findNearestPose( const Pose );
    static double findDistanceBetweenPoses( const InternalPose &, const InternalPose & );

    int findGoalPose(int currentIndex);
    void driveToPoint(const Pose iipose, int goalPoseIndex, const std::shared_ptr<okapi::OdomChassisController> &controller );
    bool isPoseWithinCircle( const InternalPose &point, const InternalPose &centerPose, const double &lookaheadDistance );

};

}//autolib
